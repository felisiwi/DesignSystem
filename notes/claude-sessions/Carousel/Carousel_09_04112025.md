# Carousel_09_04112025.md

**Date:** November 4, 2025  
**Focus:** Biomechanical analysis of carousel interaction failure (small hands, high screen position)  
**Type:** Bug investigation & ergonomic root cause analysis  
**Component Version:** AdaptiveCarousel.1.0.2

---

## Session Overview

Investigation into a real-world usability failure: User "Jo" (small hands) unable to trigger carousel flick/glide gestures when the carousel is positioned high on screen while holding phone one-handed. Page scrolls vertically instead of carousel responding horizontally.

---

## Problem Statement

### User Report
- **Device:** iPhone  
- **User Profile:** "Jo" - small hands  
- **Scenario:** Carousel positioned high on screen, one-handed phone grip at bottom  
- **Behavior:** Consistent failure to trigger carousel gestures â†’ page scrolls instead  
- **Initial Hypothesis (User):** Angle threshold too forgiving  

### Actual Root Cause

**Not an angle threshold problem** - it's a **geometric ergonomics issue** that the current directional lock system doesn't account for.

---

## Biomechanical Analysis

### The Three Physical Constraints

#### 1. Thumb Arc Geometry
```
Physical Reality:
- Thumb pivots from base of hand (fixed rotation point)
- Reaching upward creates natural arc motion
- Arc has significant vertical displacement even for intended horizontal movement
- Small hands = shorter radius = steeper arc angle
```

**Visual Model:**
```
Phone grip at bottom:        Thumb arc to reach high element:
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚          â”‚                    â”‚  [O]â”€â”€â”€  â”‚ â† Intended horizontal
    â”‚          â”‚                    â”‚   â•±      â”‚    swipe
    â”‚          â”‚                    â”‚  â•±       â”‚
    â”‚  [Target]â”‚                    â”‚ â•±        â”‚ â† Actual arc path
    â”‚          â”‚                    â”‚â•±         â”‚    (significant Y component)
    â”‚          â”‚                    â”‚          â”‚
    â”‚          â”‚                    â”‚          â”‚
    â””â”€â”€[ðŸ–ï¸]â”€â”€â”€â”˜                    â””â”€â”€[ðŸ–ï¸]â”€â”€â”€â”˜
```

**Impact:**
- Small hands create steeper arc angles
- Higher target position = more vertical motion component
- User **intends** horizontal, but **physics** creates diagonal path

---

#### 2. Touch Initiation Penalty
```typescript
Problem: Current system evaluates angle from first pixel of movement

Touch sequence:
1. Thumb reaches UP to make contact       â† Has upward momentum
2. First pixel of drag detected           â† Captures "reaching" phase
3. Angle calculated: ~45-60Â° (too vertical)
4. System locks to vertical scroll        â† Blocks carousel
5. User's horizontal intent never evaluated
```

**The Penalty:**
- Directional lock happens **before** the intended gesture begins
- System captures the "approach" motion, not the "swipe" motion
- No recovery mechanism once locked to wrong direction

---

#### 3. Leverage Disadvantage
```
Extended reach = reduced force/control:

Comfortable thumb zone:     Extended reach zone:
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚          â”‚               â”‚  [X] â†â”€â”€â”€ Target (weak leverage)
    â”‚          â”‚               â”‚          â”‚
    â”‚  [âœ“]â”€    â”‚ â† Optimal     â”‚          â”‚
    â”‚          â”‚               â”‚          â”‚
    â”‚          â”‚               â”‚          â”‚
    â””â”€â”€[ðŸ–ï¸]â”€â”€â”€â”˜               â””â”€â”€[ðŸ–ï¸]â”€â”€â”€â”˜
         â†‘                           â†‘
    Strong grip              Weak grip, tremor, imprecise
```

**Compound Effect:**
- Weak leverage â†’ less precise horizontal control
- Natural tremor amplified at extension
- Small unintended Y motion becomes proportionally larger

---

## Current System Limitations

### Directional Lock Implementation (v1.0.2)
```typescript
// From AdaptiveCarousel.1.0.2
const angle = Math.abs(Math.atan2(info.offset.y, info.offset.x) * (180 / Math.PI))
const totalDistance = Math.sqrt(info.offset.x ** 2 + info.offset.y ** 2)

// Lock decision at 30Â° threshold
if (totalDistance > 12 && !directionLocked) {
  if (angle < 30) {
    setDirectionLock('horizontal')  // Carousel wins
  } else if (angle > 60) {
    setDirectionLock('vertical')    // Scroll wins
  }
}
```

### Why This Fails for Small Hands/High Position

| Factor | Effect | System Response | User Experience |
|--------|--------|----------------|-----------------|
| **Thumb arc** | Initial motion has 40-50Â° angle | Misses <30Â° threshold | Locks to scroll |
| **Touch initiation** | First pixels are "reach up" not "swipe across" | Evaluated too early | Intent never detected |
| **Leverage** | Weak control creates Y wobble | Increases measured angle | Penalized for physics |
| **Screen position** | High = steeper approach angle | Worse with each cm upward | Carousel becomes unusable |

**Result:** System optimized for comfortable-reach scenarios, fails for extended-reach biomechanics.

---

## Proposed Solutions

### Option 1: Delayed Angle Evaluation (Conservative)
**Concept:** Don't evaluate direction until thumb has "settled" into the swipe motion.
```typescript
// Wait for initial approach motion to complete
const APPROACH_DISTANCE_THRESHOLD = 20  // px
const EVALUATION_START_DISTANCE = 25     // px

if (totalDistance < APPROACH_DISTANCE_THRESHOLD) {
  // Still approaching - don't evaluate yet
  return
}

if (totalDistance >= EVALUATION_START_DISTANCE && !directionLocked) {
  // Now evaluate - approach phase complete
  const angle = calculateAngle(info)
  // ... existing lock logic
}
```

**Pros:**
- Simple modification to existing system
- Allows "reaching" phase to complete before judgment
- Low risk of breaking current behavior

**Cons:**
- Adds latency (~8-12px of drag before lock)
- May feel less responsive for ideal-case users

---

### Option 2: Velocity-Based Intent Detection (Aggressive)
**Concept:** Use velocity direction, not position direction, to infer intent.
```typescript
// After initial drag distance threshold
const velocityAngle = Math.abs(
  Math.atan2(info.velocity.y, info.velocity.x) * (180 / Math.PI)
)

// Velocity indicates true intent better than position
if (velocityAngle < 35) {
  setDirectionLock('horizontal')  // Carousel
} else if (velocityAngle > 55) {
  setDirectionLock('vertical')    // Scroll
}
```

**Reasoning:**
- Velocity = "where user is going"
- Position offset = "where user has been" (includes approach)
- Velocity ignores the initial reach-up phase

**Pros:**
- More accurate intent detection
- Works better for extended reach
- No added latency

**Cons:**
- Requires minimum velocity to evaluate (won't work for very slow drags)
- Could be too permissive (false positives for scroll)

---

### Option 3: Position-Aware Thresholds (Adaptive)
**Concept:** Adjust angle threshold based on carousel's Y position on screen.
```typescript
// Get carousel position relative to viewport
const carouselRect = carouselRef.current?.getBoundingClientRect()
const carouselMidY = carouselRect ? carouselRect.top + carouselRect.height / 2 : 0
const viewportHeight = window.innerHeight

// Calculate position factor (0 = bottom, 1 = top)
const positionFactor = carouselMidY / viewportHeight

// Adjust threshold based on position
// High on screen = more lenient (harder to reach = more Y wobble expected)
const angleThreshold = 30 + (positionFactor * 15)  // 30Â° â†’ 45Â° gradient

if (angle < angleThreshold) {
  setDirectionLock('horizontal')
}
```

**Pros:**
- Directly addresses the position-dependent problem
- Self-adjusting for different layouts
- Maintains strict threshold for easy-reach positions

**Cons:**
- More complex implementation
- Requires viewport awareness
- May need device-specific tuning (phone vs tablet)

---

### Option 4: Multi-Signal Confidence Score (Sophisticated)
**Concept:** Combine multiple signals to build confidence before locking.
```typescript
function calculateDirectionConfidence(info, carouselPosition) {
  let horizontalScore = 0
  let verticalScore = 0
  
  // Signal 1: Position angle (weighted by distance traveled)
  const posAngle = Math.abs(Math.atan2(info.offset.y, info.offset.x) * (180 / Math.PI))
  if (posAngle < 30) horizontalScore += 2
  else if (posAngle < 45) horizontalScore += 1
  else if (posAngle > 60) verticalScore += 2
  
  // Signal 2: Velocity angle (stronger signal)
  const velAngle = Math.abs(Math.atan2(info.velocity.y, info.velocity.x) * (180 / Math.PI))
  if (velAngle < 35) horizontalScore += 3
  else if (velAngle > 55) verticalScore += 3
  
  // Signal 3: Position-based leniency
  const positionLeniency = calculatePositionFactor(carouselPosition)
  horizontalScore += positionLeniency  // Bonus for high positions
  
  // Signal 4: Total distance (confidence grows with distance)
  const totalDist = Math.sqrt(info.offset.x ** 2 + info.offset.y ** 2)
  if (totalDist > 30) {
    // More confident after significant drag
    horizontalScore *= 1.2
    verticalScore *= 1.2
  }
  
  return { horizontalScore, verticalScore }
}

// Lock when confidence is clear
if (horizontalScore > 4 && horizontalScore > verticalScore * 1.5) {
  setDirectionLock('horizontal')
} else if (verticalScore > 4 && verticalScore > horizontalScore * 1.5) {
  setDirectionLock('vertical')
}
```

**Pros:**
- Most robust solution
- Adapts to multiple scenarios
- Can be tuned with real user data

**Cons:**
- Complex to implement and tune
- May need A/B testing to validate
- Harder to debug

---

## Recommended Implementation Strategy

### Phase 1: Quick Win (Ship This Week)
**Implement Option 1 (Delayed Evaluation) + Option 2 (Velocity Bias)**
```typescript
const APPROACH_THRESHOLD = 20  // Don't evaluate until 20px drag
const LOCK_THRESHOLD = 25      // Make decision at 25px

if (totalDistance < APPROACH_THRESHOLD) {
  return  // Let user "settle" into gesture
}

if (totalDistance >= LOCK_THRESHOLD && !directionLocked) {
  // Use velocity angle instead of position angle
  const velocityAngle = Math.abs(
    Math.atan2(info.velocity.y, info.velocity.x) * (180 / Math.PI)
  )
  
  if (velocityAngle < 35) {
    setDirectionLock('horizontal')
  } else if (velocityAngle > 55) {
    setDirectionLock('vertical')
  }
  // 35-55Â° range remains ambiguous (no lock yet)
}
```

**Rationale:**
- Addresses both "approach phase" and "intent detection" problems
- Minimal code change, low risk
- Should solve "Jo's" specific issue

---

### Phase 2: Validation (Next Sprint)
1. **Test with "Jo"** - does delayed + velocity solve the problem?
2. **Test with other users** - any regressions?
3. **Collect diagnostic data** - angle distributions for high vs low positions
4. **A/B test** if possible - old system vs new system

---

### Phase 3: Adaptive System (If Still Issues)
**Implement Option 3 (Position-Aware) or Option 4 (Multi-Signal)**

Only pursue if Phase 1 doesn't adequately solve the problem. These are more complex and require more testing.

---

## Key Insights

### 1. Angle Threshold Alone is Insufficient
The 30Â° threshold is good for **ideal reach scenarios** but fails when:
- Carousel positioned high on screen
- User has small hands / short reach
- One-handed grip from bottom

### 2. "First Pixel Bias" Problem
Evaluating direction from the very first pixel of movement captures the **approach motion**, not the **intended swipe direction**.

**Solution:** Wait for the gesture to "settle" before evaluating.

### 3. Position Matters
Screen position isn't just about UI layout - it's about **biomechanical constraints**:
- Higher = steeper approach angle
- Higher = weaker leverage
- Higher = less control precision

**Current system treats all positions equally** â†’ fails for ergonomically challenging scenarios.

### 4. Velocity is Intent
- **Position offset** = "where the thumb has been" (includes mistakes, approach, wobble)
- **Velocity vector** = "where the thumb is going" (filters noise, reveals intent)

**Velocity is a clearer signal of user intent.**

---

## Testing Recommendations

### Immediate Testing (Before Implementation)
1. **Reproduce the issue:**
   - Get device with small screen
   - Position carousel at top 1/3 of viewport
   - Hold phone one-handed at bottom
   - Try to perform horizontal swipes

2. **Measure angle distribution:**
   - Log actual angles for high-position vs low-position
   - Confirm hypothesis that high position â†’ steeper angles

### Post-Implementation Testing
1. **User "Jo" validation:**
   - Can they now successfully trigger carousel?
   - Does it feel natural or still awkward?

2. **Regression testing:**
   - Do normal-reach scenarios still work well?
   - Any new false positives (carousel triggers when user wants to scroll)?

3. **Cross-device validation:**
   - iPhone SE (small) vs iPhone Pro Max (large)
   - Different hand sizes
   - Different carousel positions

---

## Open Questions

1. **Threshold Tuning:**
   - Is 20px approach threshold optimal, or should it be 15px / 25px?
   - Should velocity angle threshold be 35Â° or 40Â°?

2. **Ambiguous Zone Handling:**
   - What happens in the 35-55Â° range where neither direction is clear?
   - Should we delay lock further, or default to one direction?

3. **Device-Specific Calibration:**
   - Do small phones need different thresholds than tablets?
   - Should we use viewport height as a scaling factor?

4. **Accessibility:**
   - How does this affect users with motor control issues?
   - Should there be an "easy mode" toggle for difficult scenarios?

---

## Files Referenced

- **AdaptiveCarousel.1.0.2.tsx** - Current production code
- **Carousel_MASTER.md** - Comprehensive gesture detection documentation
- **Carousel_06.md** - Original directional lock implementation notes
- **CSV swipe diagnostics** - Gesture data (Felix, Pierre, Hani, Ben, Max, Caitlin)

---

## Next Session

### High Priority
1. **Implement Phase 1 solution** (delayed + velocity)
2. **Test with "Jo"** to validate fix
3. **Collect new diagnostic data** with position tracking

### Medium Priority
4. **Analyze angle distributions** by screen position
5. **Consider position-aware thresholds** if Phase 1 insufficient

### Low Priority
6. **Document biomechanical best practices** for touch UI
7. **Research industry standards** for position-dependent interaction

---

## Document Metadata

**Session Number:** 09  
**Date:** November 4, 2025  
**Duration:** ~20 minutes  
**Type:** Root cause analysis & solution design  
**Status:** Solution designed, pending implementation  
**Follow-up Required:** Yes - implement Phase 1, test with "Jo"  
**Key Discovery:** First-pixel bias + biomechanical constraints = usability failure for extended-reach scenarios

---

**End of Summary**